# Performance Analysis Guide

This guide explains how to interpret and analyze the performance metrics generated by the dp-playwright test suite.

## Understanding the Metrics

### CSV Structure
The test suite generates CSV files with the following columns:

```csv
timestamp,href,text,jsHeapUsedBytes,jsHeapTotalBytes,taskDurationMs,deltaHeapUsedBytes
2025-09-22T20:15:48.3595408Z,/adaptive-components/?path=/docs/1-intro--docs,1. Intro,81325964,248262656,0.008,0
```

### Metric Definitions

| Column | Description | Unit | Interpretation |
|--------|-------------|------|----------------|
| `timestamp` | When the measurement was taken | ISO 8601 | Timeline analysis |
| `href` | Page URL that was tested | String | Page identification |
| `text` | Display name of the page | String | Human-readable identifier |
| `jsHeapUsedBytes` | Current JavaScript heap usage | Bytes | Memory consumption |
| `jsHeapTotalBytes` | Total JavaScript heap size | Bytes | Memory allocation |
| `taskDurationMs` | Main thread task duration | Milliseconds | Rendering performance |
| `deltaHeapUsedBytes` | Memory change from previous page | Bytes | Memory leak detection |

## Performance Analysis

### 1. Memory Usage Analysis

#### Baseline Memory
- **Typical Range**: 80-100 MB for complex Storybook applications
- **Acceptable**: < 150 MB for most use cases
- **Warning**: > 200 MB may indicate memory leaks

#### Memory Growth Patterns
```bash
# Look for memory leaks (consistently positive deltas)
grep -E ",[0-9]+$" storybook_metrics_*.csv | awk -F',' '{print $7}' | sort -n

# Find pages with highest memory usage
sort -t',' -k4 -nr storybook_metrics_*.csv | head -10
```

#### Memory Cleanup Indicators
- **Negative Deltas**: Good - indicates proper cleanup
- **Zero Deltas**: Neutral - no change
- **Positive Deltas**: Monitor - may indicate memory growth

### 2. Rendering Performance

#### Task Duration Analysis
- **Excellent**: < 0.010ms
- **Good**: 0.010-0.050ms
- **Acceptable**: 0.050-0.100ms
- **Poor**: > 0.100ms

#### Performance Bottlenecks
```bash
# Find slowest rendering pages
sort -t',' -k6 -nr storybook_metrics_*.csv | head -10

# Find pages with task duration > 0.1ms
awk -F',' '$6 > 0.1' storybook_metrics_*.csv
```

### 3. Component-Specific Analysis

#### Heavy Components
Some components naturally consume more memory:
- **Icon Libraries**: 5-10MB delta (expected)
- **Data Grids**: 2-5MB delta (expected)
- **Rich Text Editors**: 3-8MB delta (expected)

#### Lightweight Components
- **Basic Buttons**: < 1MB delta
- **Simple Forms**: 1-2MB delta
- **Text Components**: < 1MB delta

## Data Analysis Tools

### 1. Command Line Analysis

#### Memory Trends
```bash
# Calculate average memory usage
awk -F',' 'NR>1 {sum+=$4; count++} END {print "Average JS Heap Used:", sum/count/1024/1024 "MB"}' storybook_metrics_*.csv

# Find memory peaks
awk -F',' 'NR>1 {if($4>max) max=$4} END {print "Peak Memory Usage:", max/1024/1024 "MB"}' storybook_metrics_*.csv
```

#### Performance Summary
```bash
# Count pages tested
wc -l storybook_metrics_*.csv

# Find slowest pages
sort -t',' -k6 -nr storybook_metrics_*.csv | head -5

# Calculate average task duration
awk -F',' 'NR>1 {sum+=$6; count++} END {print "Average Task Duration:", sum/count "ms"}' storybook_metrics_*.csv
```

### 2. Excel/Spreadsheet Analysis

#### Import CSV Data
1. Open CSV file in Excel/Google Sheets
2. Create pivot tables for analysis
3. Generate charts for trend visualization

#### Useful Formulas
```excel
# Memory usage in MB
=ROUND(C2/1024/1024,2)

# Performance grade
=IF(D2<0.01,"Excellent",IF(D2<0.05,"Good",IF(D2<0.1,"Acceptable","Poor")))

# Memory trend
=IF(E2<0,"Cleanup",IF(E2=0,"Stable","Growth"))
```

### 3. Python Analysis Script

```python
import pandas as pd
import matplotlib.pyplot as plt

# Load data
df = pd.read_csv('storybook_metrics_*.csv')

# Convert bytes to MB
df['jsHeapUsedMB'] = df['jsHeapUsedBytes'] / 1024 / 1024
df['jsHeapTotalMB'] = df['jsHeapTotalBytes'] / 1024 / 1024
df['deltaHeapUsedMB'] = df['deltaHeapUsedBytes'] / 1024 / 1024

# Memory usage over time
plt.figure(figsize=(12, 6))
plt.plot(df['jsHeapUsedMB'])
plt.title('Memory Usage Over Time')
plt.xlabel('Page Index')
plt.ylabel('Memory (MB)')
plt.show()

# Performance distribution
plt.figure(figsize=(10, 6))
plt.hist(df['taskDurationMs'], bins=20)
plt.title('Task Duration Distribution')
plt.xlabel('Duration (ms)')
plt.ylabel('Frequency')
plt.show()

# Top memory consumers
top_memory = df.nlargest(10, 'jsHeapUsedMB')[['text', 'jsHeapUsedMB']]
print("Top 10 Memory Consumers:")
print(top_memory)
```

## Performance Benchmarks

### Memory Benchmarks
| Component Type | Expected Memory | Warning Threshold |
|----------------|-----------------|-------------------|
| Basic Components | 80-90 MB | > 120 MB |
| Data Components | 90-110 MB | > 150 MB |
| Rich Components | 100-130 MB | > 180 MB |
| Full Application | 120-150 MB | > 200 MB |

### Performance Benchmarks
| Task Duration | Performance Grade | Action Required |
|---------------|-------------------|-----------------|
| < 0.010ms | Excellent | None |
| 0.010-0.050ms | Good | Monitor |
| 0.050-0.100ms | Acceptable | Optimize if possible |
| > 0.100ms | Poor | Investigate and optimize |

## Troubleshooting Performance Issues

### High Memory Usage
1. **Check for Memory Leaks**: Look for consistently positive deltas
2. **Identify Heavy Components**: Find components with large memory deltas
3. **Review Component Lifecycle**: Ensure proper cleanup
4. **Optimize Asset Loading**: Lazy load heavy resources

### Slow Rendering
1. **Identify Slow Pages**: Find pages with high task duration
2. **Check Component Complexity**: Simplify complex components
3. **Optimize Rendering**: Use React.memo, useMemo, useCallback
4. **Review Bundle Size**: Check for unnecessary dependencies

### Memory Leaks
1. **Event Listeners**: Ensure proper cleanup
2. **Timers**: Clear intervals and timeouts
3. **Subscriptions**: Unsubscribe from observables
4. **DOM References**: Remove event listeners and references

## Best Practices

### Monitoring
- Run performance tests regularly
- Track trends over time
- Set up alerts for performance regressions
- Monitor memory usage patterns

### Optimization
- Profile before optimizing
- Focus on the biggest impact areas
- Test optimizations thoroughly
- Document performance decisions

### Reporting
- Include performance metrics in CI/CD
- Generate performance reports
- Share insights with development team
- Track performance improvements

## Example Analysis Report

```markdown
# Performance Analysis Report - 2025-09-22

## Summary
- **Total Pages Tested**: 395
- **Average Memory Usage**: 89.2 MB
- **Peak Memory Usage**: 97.0 MB
- **Average Task Duration**: 0.012 ms

## Key Findings
1. **Memory Management**: Good - 78% of pages show memory cleanup
2. **Performance**: Excellent - 95% of pages render in < 0.05ms
3. **Heavy Components**: Icons page shows expected 7.8MB delta

## Recommendations
1. Monitor memory usage trends over time
2. Investigate pages with task duration > 0.1ms
3. Consider lazy loading for heavy components
```

This comprehensive performance analysis guide will help you understand and optimize your Storybook application's performance based on the metrics collected by the dp-playwright test suite.
